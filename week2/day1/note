面向对象编程（oop）object oriented programming 以对象数据类型为导向的编程
四种设计模式：单例模式  工厂模式  构造函数模式 原型模式

## 单例模式：就是一个对象  DOM库的封装就利用这种模式
把所有的变量或方法，当成对象的属性存储在一个空间里，这个空间称为命名空间
1.解决问题：
    1.变量之间的冲突和覆盖
    2.具有封装性，是最简单的一种模块化开发的方式
2.模块之间的调用
  - 相同模块之间调用  this.属性名
  - 不同模块之间调用  模块名.属性名

3.缺点
 - 手工业模式,效率低,有很多冗余代码  - 解决的办法 工厂模式
 - 在其他模块所有的内容都可以拿到，没有隐私 - 解决办法 高级单例模式

## 工厂模式
 解决：批量生产
 缺点：没有实现产品差异化  -解决办法：构造函数模式

 对象：万物皆对象  地球
 类：把这个笼统的对象分类了下（抽象的概念）   人类,植物类，微生物类...
 实例：具体的事物

 对象(Object,Array,RegExp...) 内置类
 var ary = [1,2,3]; ary是一个实例 是Array类的实例
 var reg = /\d/;
 var ary = new Array(1,2,3);

 自定义类
 构造函数(类) 是一个抽象的事物
 要想有实例，得通过new 运行构造函数才能生产出具体事物
 1.与工厂模式区别：
  - 第一步创建obj和第三步return obj不需要写了,系统会自动完成
  - 构造函数里用this代表创建出来的对象
 2.构造函数的细节知识点
  - new 运行的函数才成为构造函数,这时函数后面的小括号若不传参可以省略
  - 构造函数里this 指 new运行函数时返回的对象也就是实例
  - this.xxx定义的属性才跟实例有关，如果var a = 10;这种方式定义的变量跟实例无关
  - 若手动写return后的值
   + 基本类型的值没有影响
   + 引用类型的值会默认返回的实例覆盖

## 原型模式
 定义在原型上的属性表示是所有实例公有的方法
 （这三句话强制记下来）
  - 所有的函数都有一个属性prototype,prototype指向默认的原型对象
  - 所有的对象都有一个属性__proto__,指向所属类的原型
  - 默认原型对象上有个属性constructor,指向对应的构造函数
 1.属性查找的顺序
  - 若实例上能找到，则用私有的属性
  - 若实例上没找到，则去所属类的原型上查找，找到，则用公有的属性
  - 若原型上也没找到，则继续通过__proto__去所属类的原型上查找....直到找到Object.prototype，若还没找到则返回undefined
  这样通过__proto__查找的过程,就形成了原型链 ，__proto__也是实现继承的关键
Object是基类
Person类，Array类 是派生类  都是Object类的子类
子类的实例可以调用父类原型上的属性，子类的实例可以通过__proto__查找到父类原型上的属性

## 构造函数+原型模式学完后的作用
 - 自定义类
 - 查看，修改或者添加内置类原型上的方法

## 深入学习函数
 - 普通函数
   1.形成私有作用域 2.形参赋值 3.变量提升 4.代码从上往下执行
 - 构造函数
   类，实例，原型
 - 对象

